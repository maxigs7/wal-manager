-- This script was generated by the Schema Diff utility in pgAdmin 4
-- For the circular dependencies, the order in which Schema Diff writes the objects is not very sophisticated
-- and may require manual changes to the script to ensure changes are applied in the correct order.
-- Please report an issue for any failure with the reproduction steps.

CREATE OR REPLACE FUNCTION public.get_ocurrences(
	id uuid)
    RETURNS TABLE(id uuid, date timestamp without time zone)
    LANGUAGE 'sql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$

  with recursive ocurrences(n) as (
    values (1)
    union all
    select n + 1 from ocurrences where n < 1000
  )

  select
    t.id,
    t.date + o.n * interval '1 month' as date
  from ocurrences o
    full join public.transaction as t on true
  where t.id = id and t."isRecurring" = true
    and not exists(select 1
                  from transaction p
                  where
                        p."parentTransactionId" = t.id
                    and cast(p.date as date) = cast((t.date + o.n * interval '1 month') as date))

$BODY$;

ALTER FUNCTION public.get_ocurrences(uuid)
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.get_ocurrences(uuid) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.get_ocurrences(uuid) TO anon;

GRANT EXECUTE ON FUNCTION public.get_ocurrences(uuid) TO authenticated;

GRANT EXECUTE ON FUNCTION public.get_ocurrences(uuid) TO postgres;

GRANT EXECUTE ON FUNCTION public.get_ocurrences(uuid) TO service_role;

CREATE OR REPLACE FUNCTION public.get_balance(
	"endDate" timestamp without time zone)
    RETURNS TABLE(amount numeric, date timestamp without time zone)
    LANGUAGE 'sql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$

  select
    SUM(case
          -- when t.is_paid = false then 0
          when type = 'expenses' then amount * (-1)
          when type = 'incomes' then amount
          else 0
        end) as amount,
    date_trunc('month', "endDate") + interval '1 month' as date
  from public.transaction as t
    left join public.get_ocurrences(t.id) as o
      on o.id = t.id and o.date <= "endDate"
  where
        ( o.date is not null and o.date <= "endDate" )
    or  ( o.date is null and t.date <= "endDate" )

$BODY$;

ALTER FUNCTION public.get_balance(timestamp without time zone)
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.get_balance(timestamp without time zone) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.get_balance(timestamp without time zone) TO anon;

GRANT EXECUTE ON FUNCTION public.get_balance(timestamp without time zone) TO authenticated;

GRANT EXECUTE ON FUNCTION public.get_balance(timestamp without time zone) TO postgres;

GRANT EXECUTE ON FUNCTION public.get_balance(timestamp without time zone) TO service_role;

CREATE OR REPLACE FUNCTION public.get_transactions(
	"startDate" timestamp without time zone,
	"endDate" timestamp without time zone)
    RETURNS TABLE(account character varying, amount numeric, "creditCard" character varying, date timestamp without time zone, description character varying, "feeNumber" smallint, id uuid, "isPaid" boolean, "rootCategory" character varying, "rootCategoryColor" character varying, "rootCategoryIcon" character varying, "subCategory" character varying, type "transactionType")
    LANGUAGE 'sql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$

  select
    null as account,
    amount,
    null as "creditCard",
    date,
    null as description,
    null as "feeNumber",
    null as id,
    null as "isPaid",
    null as "rootCategory",
    null as "rootCategoryColor",
    null as "rootCategoryIcon",
    null as "subCategory",
    null as type
  from public.get_balance("startDate" - interval '1 seconds')
  where amount > 0

  union all

  select
    a.name as account,
    case
      -- when t.is_paid = false then 0
      when t.type = 'expenses' then t.amount * (-1)
      when t.type = 'incomes' then t.amount
      else 0
    end as amount,
    cc.name as "creditCard",
    COALESCE(t."billedDate", o.date, t.date) as date,
    t.description,
    t."feeNumber",
    t.id,
    t."isPaid",
    COALESCE("parentCat".name, cat.name) as "rootCategory",
    COALESCE("parentCat".color, cat.color) as "rootCategoryColor",
    COALESCE("parentCat".icon, cat.icon) as "rootCategoryIcon",
    case when "parentCat".id is null then null else cat.name end as "subCategory",
    t.type
  from transaction as t
    inner join account as a
      on t."accountId" = a.id
    left join "creditCard" as cc
      on t."creditCardId" = cc.id

    inner join category as cat
      on t."categoryId" = cat.id
    left join category as "parentCat"
      on cat."parentId" = "parentCat".id

    left join public.get_ocurrences(t.id) as o
      on o.id = t.id and o.date >= "startDate" and o.date <= "endDate"

  where
        COALESCE(o.date, t.date) >= "startDate"
    and COALESCE(o.date, t.date) <= "endDate"

  order by date asc

$BODY$;

ALTER FUNCTION public.get_transactions(timestamp without time zone, timestamp without time zone)
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.get_transactions(timestamp without time zone, timestamp without time zone) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.get_transactions(timestamp without time zone, timestamp without time zone) TO anon;

GRANT EXECUTE ON FUNCTION public.get_transactions(timestamp without time zone, timestamp without time zone) TO authenticated;

GRANT EXECUTE ON FUNCTION public.get_transactions(timestamp without time zone, timestamp without time zone) TO postgres;

GRANT EXECUTE ON FUNCTION public.get_transactions(timestamp without time zone, timestamp without time zone) TO service_role;

